package com.emriver.geomodel.table;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.elmocity.elib.net.IUDPListener;
import com.elmocity.elib.net.UDPClient;
import com.elmocity.elib.util.WireMessage;


public class EthernetTableConnection implements ITableConnection, IUDPListener
{
	// Info about the underlying wire connection
	private String serverAddress;
	private int serverPort;
	private UDPClient ethernet;

	// List of objects that want to know when we receive payloads containing current Device values/status.
	private ArrayList<ITableConnectionListener> listeners = new ArrayList<ITableConnectionListener>();

	
	// Protocol specific data:
	
	// All use of the term "timestamp" in this file refers to a counter-style value generated by the
	// embedded table computer (in ms).  It is probably zero-based on their boot time or connection setup.
	// Since we have no idea what that value is during our connection setup and handshaking, use zero for "dunno".
	// NOTE: there are no relative times (like "5 sec from now")...all timestamps are full absolute values.
	
	// Unique request ID, each request down this table connection should increment this id as they use it.
	// WARNING this is an unsigned byte for transport to and from the table, so it wraps constantly.
	private volatile Long id = new Long(100);	// Boxed value for synchronization
	
	
	// Last known timestamp from the table (unknown epoch)
	// WARNING this is an unsigned int for transport to and from the table.
	private volatile long lastKnownTableTimestamp = 0;
	
	// Last known sequence number that the table sent us in a message.  We are supposed to echo this back in the next request we send.
	// WARNING this is an unsigned byte for transport to and from the table, so it wraps constantly.
	private volatile long lastKnownTableSequenceNumber = 0;
	
	// Transported as unsigned short
	private static final int SYSTEM_CONTROL_MAGIC		= 0x4543;	// 'SC'
	private static final int SYSTEM_STATUS_MAGIC		= 0x4553;	// 'SS'
	private static final int OPERATOR_CONTROL_MAGIC		= 0x5043;	// 'OC'
	private static final int OPERATOR_STATUS_MAGIC		= 0x5053;	// 'OS'

	// Transported as unsigned byte
	private static final int SYSTEM_PROTOCOL = 0x01;
	private static final int SYSTEM_ID = 0x01;

	// COMMANDS
	private static final int OPERATOR_CONTROL_CMD_MOVE = 0x01;
	private static final int OPERATOR_CONTROL_CMD_STOP = 0x02;
	
	
	private static final Logger logger = LoggerFactory.getLogger(EthernetTableConnection.class);


	
	public EthernetTableConnection(String serverAddress, int serverPort)
	{
		this.serverAddress = serverAddress;
		this.serverPort = serverPort;
	}

	@Override
	public void connect()
	{
		ethernet = new UDPClient();
		boolean worked = ethernet.startup(serverAddress, serverPort, this);
		if (!worked) {
			logger.warn("unable to startup UDP {} {}", serverAddress, serverPort);
			ethernet = null;
			return;
		}
		
		startKeepAliveThread();
	}

	@Override
	public void disconnect()
	{
		stopKeepAliveThread();
		
		if (ethernet != null) {
			ethernet.shutdown();
			ethernet = null;
		}
	}

	@Override
	public boolean isConnected()
	{
		return ethernet != null;
	}

	@Override
	public void sendRequest(Request request)
	{
		if (ethernet == null) {
			return;
		}

		WireMessage message = makeBinRequestMessage(request);
		ethernet.sendRequest(message);
	}

	@Override
	public void addTableListener(ITableConnectionListener listener)
	{
		listeners.add(listener);
	}

	// ---------------------------------------------------------------------------------------

	// Callback from the underlying wire object, each time a message is received.
	@Override
	public void receiveMessage(WireMessage message)
	{
//		if (ethernet == null) {
//			return;
//		}

		Response[] responses = parseBinResponseMessage(message);
		if (responses == null) {
			return;
		}

		// Check to find any listeners and give them the payload
		for (ITableConnectionListener l : listeners) {
			l.receiveResponses(responses);
		}

		return;
	}

	// ---------------------------------------------------------------------------------------
	
	Thread keepAliveThread = null;
	private void startKeepAliveThread()
	{
		if (keepAliveThread != null) {
			logger.warn("multiple calls to startKeepAliveThread() not allowed.");
			return;
		}
		
		keepAliveThread = new Thread(() ->
		{
			keepAliveThread.setName("EthKeepAlive");

			final int msCycle = 10000;			// TODO ping the table every 10 seconds
			while (true) {

				if (ethernet != null) {
					// Make up a simple control message to let the table know we are here, which will start sending us periodic updates.
					Request request = new Request(Device.DEV_UNKNOWN, TableController.CMD_SET, 0, 0);
					sendRequest(request);
				}

				try {
					Thread.sleep(msCycle);
				}
				catch (InterruptedException e) {
					logger.debug("keep alive thread asked to quit");
					break;
				}
			}
		});
		keepAliveThread.start();		
	}
	
	private void stopKeepAliveThread()
	{
		if (keepAliveThread != null) {
			keepAliveThread.interrupt();
			keepAliveThread = null;
		}
	}
	
	// ---------------------------------------------------------------------------------------

	// Max size of the backing store buffer to build the message into.
	// TODO probably could be up to MTU size?
	private final int STORE_SIZE = 1024;

	
	/**
	 * Given a request to send (from the application layer above), create a wire level message that matches the
	 * protocol we are speaking on the particular type of connection (UDP/serial/debugloopback)
	 * 
	 * @param request
	 * @return
	 */
	public WireMessage makeBinRequestMessage(Request request)
	{
		// Create a backing store buffer to build the message into.
		ByteArrayOutputStream store = new ByteArrayOutputStream(STORE_SIZE);
		
		DataOutputStream stream = new DataOutputStream(store);
	
		// Figure out the device ID.
		// NOTE This local Java enum is hard coded to match the numeric values of the remote "Operators" on the table.
		int deviceID = request.device.getNumValue();

		// NOTE chopping the long to int here, knowing it will get chopped down to 8-bit unsigned on xmit anyway
		int requestID;
		synchronized (id)
		{
			requestID = (int) (id % 256);
			id++;
			// TODO need to wrap this before Long.MAX_VALUE, and do so on a 8-bit mask
		}
		
		// NOTE wrap this sequence number back to 8-bit unsigned
		int lastKnowTableSequenceNumberModded = (int) (lastKnownTableSequenceNumber % 256);
		
		// Figure out the requested value (in 10ths of degrees as a signed short)
		// NOTE chopping the long to int here, knowing it will get chopped down to 16-bit unsigned on xmit anyway
		int requestedValue = (int) Math.round(request.value);
		if (request.device == Device.DEV_ROLL || request.device == Device.DEV_PITCH) {
			requestedValue = (int) Math.round(request.value * 10.0);
		}
		
		int command = OPERATOR_CONTROL_CMD_MOVE;
		if (request.command.equals(TableController.CMD_STOP)) {
			command = OPERATOR_CONTROL_CMD_STOP;
		}
		
		// Ask for the new requested value to be reached within X seconds
		// TODO this just uses the last known timestamp, but that may have been received several seconds ago.
		long atFutureTimestamp = lastKnownTableTimestamp + (request.seconds * 1000);	// 1000 ms per sec
		
		try {
			// Capsule 1 - System Control
			stream.writeByte(8);											// bytes_after			// WARNING conversion from int to unsigned byte
			stream.writeByte(SYSTEM_PROTOCOL);								// protocol_version		// WARNING conversion from int to unsigned byte
			stream.writeShort(SYSTEM_CONTROL_MAGIC);						// magic				// WARNING conversion from int to unsigned short
			
			stream.writeByte(requestID);									// segment_number		// WARNING conversion from int to unsigned byte
			stream.writeByte(lastKnowTableSequenceNumberModded);			// rx_seq				// WARNING conversion from int to unsigned byte
			stream.writeShort(0);											// padding
			stream.writeInt(longToUnsignedInt(lastKnownTableTimestamp));	// abs timestamp		// WARNING conversion from long to unsigned int
			
			// Special flag to tell us just to send the header capsule to kickstart the table to send us packets on startup. 
			if (!(request.device == Device.DEV_UNKNOWN)) {
				// Capsule 2 - Operator
				stream.writeByte(8);											// bytes_after			// WARNING conversion from int to unsigned byte
				stream.writeByte(deviceID);										// device_id			// WARNING conversion from int to unsigned byte
				stream.writeShort(OPERATOR_CONTROL_MAGIC);						// magic				// WARNING conversion from int to unsigned short
				
				stream.writeShort(requestedValue);								// requested_value		// WARNING conversion from int to unsigned short
				stream.writeByte(command);										// command				// WARNING conversion from int to unsigned byte
				stream.writeByte(0);											// padding
				stream.writeInt(longToUnsignedInt(atFutureTimestamp));			// abs timestamp		// WARNING conversion from long to unsigned int
			}

		}
		catch (IOException e) {
			e.printStackTrace();
		}
		
		// Return the byte sequence in a wire container
		byte[] buf = store.toByteArray();
		WireMessage message = new WireMessage(buf, buf.length);
		message.debugHexDump();
		return message;
	}
	
	// Parse the packet from the wire. 
	public Response[] parseBinResponseMessage(WireMessage message)
	{
		// Convert the wire byte sequence into a usable stream.
		ByteArrayInputStream store = new ByteArrayInputStream(message.getData());
		DataInputStream stream = new DataInputStream(store);

		ArrayList<Response> responses = new ArrayList<Response>(10);
		
		// The & operator forces the promotion of the read byte/short/int to an int BEFORE the mask is performed.
		// So first they get sign-extended to int, then we mask off the bits we want and store, so the upper bytes are zeroed.
		try {
			// Capsule 1 - System Status
			int systemPayloadBytes = stream.readByte() & 0xFF;						// WARNING conversion from unsigned byte to signed int
			int systemProtocol = stream.readByte() & 0xFF;							// WARNING conversion from unsigned byte to signed int
			int systemMagic = stream.readShort() & 0xFFFF;							// WARNING conversion from unsigned short to signed int

			if (systemPayloadBytes != 8) {
				logger.warn("bad systemPayloadBytes {}", systemPayloadBytes);
			}
			if (systemProtocol != SYSTEM_PROTOCOL) {
				logger.warn("bad systemProtocol {}", systemProtocol);
			}
			if (((short)systemMagic) != ((short)SYSTEM_STATUS_MAGIC)) {				// WARNING comparison of unsigned values as signed values
				logger.warn("bad systemMagic {}", systemMagic);
			}

			int systemStatusSequence = stream.readByte() & 0xFF;					// WARNING conversion from unsigned byte to signed int
			int systemEchoSequence = stream.readByte() & 0xFF;						// WARNING conversion from unsigned byte to signed int
			int systemID = stream.readShort() & 0xFFFF;								// WARNING conversion from unsigned short to signed int
			long systemCurrentTimestamp = unsignedIntToLong(stream.readInt());		// WARNING conversion from unsigned int to signed long

			// Squirrel away the protocol state information we need to create future messages
			lastKnownTableTimestamp = systemCurrentTimestamp;
			lastKnownTableSequenceNumber = systemStatusSequence;

			// Read zero or more Operator Status capsules, there is usually one per Device.
			while (true)
			{
				int avail = stream.available();
				if (avail < 16) {
					// Not enough data for a complete response, so bail out
					break;
				}
				
				// Capsule 2 - Operator Status
				int operatorPayloadBytes = stream.readByte() & 0xFF;						// WARNING conversion from unsigned byte to signed int
				int operatorDeviceID = stream.readByte() & 0xFF;							// WARNING conversion from unsigned byte to signed int
				int operatorMagic = stream.readShort() & 0xFFFF;							// WARNING conversion from unsigned short to signed int
	
				int operatorCurrentValue = stream.readShort(); /// & 0xFFFF;						// WARNING conversion from unsigned short to signed int
				int operatorFlags = stream.readShort() & 0xFFFF;							// WARNING conversion from unsigned short to signed int
				int operatorRequestedValue = stream.readShort(); // & 0xFFFF;					// WARNING conversion from unsigned short to signed int
				int pad = stream.readShort() & 0xFFFF;										// WARNING conversion from unsigned short to signed int
				long operatorRequestedTimestamp = unsignedIntToLong(stream.readInt());		// WARNING conversion from unsigned int to signed long
			

				// Create the final response we return to caller. 
				Response response = new Response();

				// Convert from wire value to local Enum
				response.device = Device.getByValue(operatorDeviceID);
				// TODO not sure how to propagate error conditions/info
				response.status = TableController.RSP_OK;

				response.value = operatorCurrentValue;
				if (response.device == Device.DEV_ROLL || response.device == Device.DEV_PITCH) {
					// Convert from 10ths of degrees into floating point
					response.value = operatorCurrentValue / 10.0;
				}

				// Timestamps in the future mean the table is still working on a prior move command.
				response.seconds = 0;									
				if ((operatorRequestedTimestamp > 0) && (operatorRequestedTimestamp - lastKnownTableTimestamp > 0)) {
					response.seconds = (int) ((operatorRequestedTimestamp - lastKnownTableTimestamp) / 1000);				// WARNING  should be safe to truncate into int
				}
				
//				logger.debug("got ethernet response raw:");
//				message.debugHexDump();
				
				// Hack to cutdown the trace output
				if (response.device == Device.DEV_PITCH) {
					logger.info("got ethernet response {}", response.debugString());
				}
				
				responses.add(response);
			}
		}
		catch (Exception e) {
			// Could happen on stream reading problems if the incoming packet is malformed or truncated.
			// Could be parsing/conversion problems with numeric values.
			return null;
		}

		// toArray copies content into other array
		Response result[] = new Response[responses.size()];
		result = responses.toArray(result);
		return result;

//		return (Response[]) responses.toArray();
	}
	
	// Mask operations promote the left side value to -int- before the mask is performed, so leading zeros on masks are needed.
	private static long unsignedIntToLong(int unsignedInt)
	{
		byte[] payload = toArray(unsignedInt);

		long result = 0x00FF & payload[0];
		result <<= 8;
		result += (0x00FF & payload[1]);
		result <<= 8;
		result += (0x00FF & payload[2]);
		result <<= 8;
		result += (0x00FF & payload[3]);
		
		return result;
	}
	
	private static int longToUnsignedInt(long myLong)
	{
		int woof = (int) (myLong & 0xFFFFFFFFL);
		return woof;
	}
	
	private static int fromArray(byte[] payload)
	{
	    ByteBuffer buffer = ByteBuffer.wrap(payload);
	    buffer.order(ByteOrder.BIG_ENDIAN);
	    return buffer.getInt();
	}

	private static byte[] toArray(int value)
	{
	    ByteBuffer buffer = ByteBuffer.allocate(4);
	    buffer.order(ByteOrder.BIG_ENDIAN);
	    buffer.putInt(value);
	    buffer.flip();
	    return buffer.array();
	}
}
